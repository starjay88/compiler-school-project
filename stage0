// Wonjae Hwang
// CS 4301
// Stage 0

#include <stage0.h>
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <ctime>
#include <iomanip>

Compiler::Compiler(char **argv) // constructor
{
	sourceFile.open(argv[1]);
	listingFile.open(argv[2]);
	objectFile.open(argv[3]);
	
}

Compiler::~Compiler()           // destructor
{
	sourceFile.close();
	listingFile.close();
	objectFile.close();
	
}

void Compiler::createListingHeader()
{
	time_t now = time(NULL);
	// print "STAGE0:", name(s), DATE, TIME OF DAY
	listingFile << "STAGE0:  " << "Wonjae Hwang       " << ctime(&now) << endl;
	// print "LINE NO:", "SOURCE STATEMENT"
	listingFile << "LINE NO." << "              SOURCE STATEMENT\n\n";
}

void Compiler::parser()
{
	nextChar();
//ch must be initialized to the first character of the source file
//nextToken();
	if (nextToken() != "program")
	{
		processError("keyword \"program\" expected");
	}
//a call to nextToken() has two effects
// (1) the variable, token, is assigned the value of the next token
// (2) the next token is read from the source file in order to make
// the assignment. The value returned by nextToken() is also
// the next token.

	prog();
//parser implements the grammar rules, calling first rule
}

void Compiler::createListingTrailer()
{
	listingFile << "COMPILATION TERMINATED      ";

	if (errorCount != 1) 
	{
		listingFile << errorCount << " ERRORS ";
	} 
	else 
	{
		listingFile << errorCount << " ERROR ";
	}

	listingFile << "ENCOUNTERED\n";
	
}

//Other routines-------------------------------------------
void Compiler::processError(string err)
{
	//Output err to listingFile 
	//Call exit(EXIT_FAILURE) to terminate program 
	listingFile << "\n" << "Error: Line " << lineNo << ": " << err << endl;
	listingFile << endl;
	errorCount++;
	createListingTrailer();

	listingFile.close();
	objectFile.close();
	
	exit(EXIT_FAILURE);
}

string Compiler::genInternalName(storeTypes stype) const
{
	static int boolCount = 0;
    static int progCount = 0;
    static int integerCount = 0;
	
	string internalName;

	if(stype == PROG_NAME)
	{
		internalName = "P" + to_string(progCount);
		progCount++;
	}
	if(stype == INTEGER)
	{
		internalName =  "I" + to_string(integerCount);
		integerCount++;
	}
	if(stype == BOOLEAN)
	{
		internalName = "B" + to_string(boolCount);
		boolCount++;
	}

	return internalName;
	
}


// Methods implementing the grammar productions---------------
//production1-------------------------------------------------------------
void Compiler::prog()           // stage 0, production 1
{
	if (token != "program")
	{
		processError("keyword \"program\" expected");
	}
	
	progStmt();
	
	if (token == "const")
	{
		consts();
	}
	
	if (token == "var")
	{
		vars();
	}
	
	if (token != "begin")
	{
		processError("keyword \"begin\" expected");
	}
	
	beginEndStmt();
	
	if (token != "$") // const char END_OF_FILE = '$'; 
	{
		processError("no text may follow \"end\"");
	}
	
}

//production2-------------------------------------------------------------
void Compiler::progStmt()       // stage 0, production 2
{
	string x;
	
	if (token != "program")
	{
		processError("keyword \"program\" expected");
	}
	
	x = nextToken();
	
	if (isNonKeyId(token) == false)
	{
		processError("program name expected");
	}
	
	if (nextToken() != ";")
	{
		processError("semicolon expected");
	}
	nextToken();
	
	code("program", x);
	insert(x,PROG_NAME,CONSTANT,x,NO,0);
	
	
}

//production3-------------------------------------------------------------
void Compiler::consts()         // stage 0, production 3
{
	if (token != "const")
	{
		processError("keyword \"const\" expected");
	}
	
	if (isNonKeyId(nextToken()) == false)
	{
		processError("non-keyword identifier must follow \"const\"");
	}
	
	constStmts();
}

//production4-------------------------------------------------------------
void Compiler::vars()           // stage 0, production 4
{
	if (token != "var")
	{
		processError("keyword \"var\" expected");
	}
	
	if (isNonKeyId(nextToken()) == false)
	{
		processError("non-keyword identifier must follow \"var\"");
	}
	 varStmts();
}

//production5-------------------------------------------------------------
void Compiler::beginEndStmt()   // stage 0, production 5
{
	if (token != "begin")
	{
		processError("keyword \"begin\" expected");
	}
	
	if (nextToken() != "end")
	{
		processError("keyword \"end\" expected");
	}
	
	if (nextToken() != ".")
	{
		processError("period expected");
	}

	nextToken();
	code("end", ".");
}

//production6-------------------------------------------------------------
void Compiler::constStmts()     // stage 0, production 6
{
	string x, y;
	
	if (isNonKeyId(token) == false)
	{
		processError("non-keyword identifier expected");
	}
	
	x = token;
	if (nextToken() != "=")
	{
		processError("\"=\" expected");
	}
	
	y = nextToken();
	
	if (y != "+" && y != "-" && y != "not" && !(isNonKeyId(y)) && !(isBoolean(y)) && !(isInteger(y)))
	{
		processError("token to right of \"=\" illegal");
	}
	
	if (y == "+" || y == "-")
	{
		
		if (!isInteger(nextToken()))
		{
			processError("integer expected after sign");
		}
		y = y + token;
	}
	
	if (y == "not")
	{
		if (whichType(nextToken()) != BOOLEAN)	 
		{
			processError("boolean expected after \"not\"");
		}
		if (token == "true")
		{
			y = "false";
		}
		else
		{
			y = "true";
		}
	}
	
	if (nextToken() != ";")
	{
		processError("semicolon expected");
	}
	
	if (whichType(y) != INTEGER && whichType(y) != BOOLEAN)	 
	{
		processError("data type of token on the right-hand side must be INTEGER or BOOLEAN");
	}
	
	insert(x,whichType(y),CONSTANT,whichValue(y),YES,1);
	x = nextToken();
	
	if (x != "begin" && x != "var" && !isNonKeyId(x))
	{		 
		processError("non-keyword identifier, \"begin\", or \"var\" expected");
	}
	if (isNonKeyId(x))
	{
		constStmts();
	}
	
}

//production7-------------------------------------------------------------
void Compiler::varStmts()       // stage 0, production 7
{
	string x,y,z;
	
	if(!isNonKeyId(token))
	{
		processError("non-keyword identifier expected");
	}
	 
	x = ids();
	 
	if (token != ":")
	{
		processError("\":\" expected");
	}
	
	z = nextToken();
	
	if(z != "integer"  && z != "boolean") 
	{ 
		processError("illegal type follows \":\"");
	}
	
	y = token;
	 
	if (nextToken() != ";")
	{
		processError("semicolon expected");
	}
	
	insert(x,whichType(y),VARIABLE,"",YES,1);
	nextToken();
	
	if(token != "begin" &&  isNonKeyId(token) == false)
	{		
		processError("non-keyword identifier or \"begin\" expected");
	}
	 //if (token is a NON_KEY_ID)
	if(isNonKeyId(token))
	{
		varStmts();
	}
}

//production8-------------------------------------------------------------
string Compiler::ids()          // stage 0, production 8
{
	string temp,tempString;
	if (!isNonKeyId(token))
	{
		processError("non-keyword identifier expected");
	}
	tempString = token;
	temp = token;
	if (nextToken() == ",")
	{
		if (!isNonKeyId(nextToken()))
		{
			processError("non-keyword identifier expected");
		}
		tempString = temp + "," + ids();
	}
	return tempString;
}


// Helper functions for the Pascallite lexicon------------------
bool Compiler::isKeyword(string s) const  // determines if s is a keyword
{
	string keywords[] = {"program", "const", "var", "integer", "boolean", "begin", "end", "true", "false", "not"};
	for (int i = 0; i < 10; i++)
	{
		if (s == keywords[i])
		{
			return true;
		}
	}
	return false;
}

bool Compiler::isSpecialSymbol(char c) const // determines if c is a special symbol
{
	char specialSymbols[] = {':', ',', ';', '=', '+', '-', '.'};
	
	for (int i = 0; i < 7; i++)
	{
		if (c == specialSymbols[i])
		{
			return true;
		}
	}
	return false;
}

bool Compiler::isNonKeyId(string s) const // determines if s is a non_key_id
{
	if(islower(s[0]) == false)
	{
		return false;
	}
	
	if(isKeyword(s))
	{
		return false;
	}
	
	for(uint i = 0; i < s.length(); i++)
	{
		if(isdigit(s[i]) == false && islower(s[i]) == false && s[i] != '_')
		{
				return false;
		}
	}
	
	if (s.back() == '_')
    {
        return false;
    }
	
	int count = 0;
	
    for(uint i = 0; i < s.length(); i++)
	{
		if(isSpecialSymbol(s[i]))
		{
			if(s[i] == '_' && count < 1)
			{
				count++;
			}
			else
			{
				return false;
			}
		}	
	}
	
	return true;
}

bool Compiler::isInteger(string s) const  // determines if s is an integer
{
	if( s == "integer")
	{
		return true;
	}
	
	if (s.empty()) 
	{ 
        return false; 
    }

    size_t start = 0; 

    if (s[0] == '+' || s[0] == '-') 
    {
        if (s.length() == 1) 
		{
            return false;
        }
        start = 1; 
    }

    for (size_t i = start; i < s.length(); i++)
    {
        if (!isdigit(static_cast<unsigned char>(s[i])))
        {
            return false; 
        }
    }
	return true;
}

bool Compiler::isBoolean(string s) const  // determines if s is a boolean
{
	if (s == "boolean")
	{
		return true;
	}
	
	if (s == "true" || s == "false")
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool Compiler::isLiteral(string s) const  // determines if s is a literal
{
	if (isBoolean(s) == false && isInteger(s) == false)
	{
		return false;
	}
	return true;
}

// Action routines-------------------------------------
void Compiler::insert(string externalName, storeTypes inType, modes inMode, string inValue, allocation inAlloc, int inUnits)
{
	string name;
	
	uint i = 0;
	
	while (i < externalName.length())
	{
		name = "";
		
		while (name == "")
		{
			while (i < externalName.length() && externalName[i] != ',') 
			{
			   name = name + externalName[i];
			   i = i + 1;
			}
			i += 1;
			
			name = name.substr(0, 15);
			
			if (symbolTable.count(name) > 0)
			{
				processError("symbol " + name + " is multiply defined"); //"multiple " + name + " definition"
			}
			else if (isKeyword(name) && name != "true" && name != "false")
			{
				processError("illegal use of keyword");
			}
			else
			{
				if (isupper(name[0]))
				{
					symbolTable.insert({name, SymbolTableEntry(name, inType, inMode, inValue, inAlloc, inUnits)});
				}
				else
				{
					symbolTable.insert({name, SymbolTableEntry(genInternalName(inType), inType, inMode, inValue, inAlloc, inUnits)});
				}
			}
		}
		if (symbolTable.size() > 256)
		{
			processError("symbol table overflow");
		}
	}		
}


storeTypes Compiler::whichType(string name) // tells which data type a name has
{
	storeTypes dataType;
	
	if (isLiteral(name))
	{
		if(isBoolean(name))
		{
			dataType = BOOLEAN;
		}
		else
		{
			dataType = INTEGER;
		}
	}
	else
	{
		if(symbolTable.count(name) == 1)
		{
			dataType = symbolTable.at(name).getDataType();
		}
		else
		{
			processError("reference to undefined constant");
		}
	}
	return dataType;
}

string Compiler::whichValue(string name) // tells which value a name has
{
	string value;
	if(isLiteral(name))
	{
		value = name;
	}
	else
	{
		auto it = symbolTable.find(name);
		
		if(symbolTable.count(name) == 1)
		{
			//value = value of symbolTable[name]
			value = (*it).second.getValue();
		}
		else
		{
			processError("reference to undefined constant");
		}
	}
	return value;
}

void Compiler::code(string op, string operand1, string operand2)
{
	if (op == "program")
	{
		emitPrologue(operand1);
	}
	else if (op == "end")
	{
		emitEpilogue();
	}
	else
	{
		processError("compiler error since function code should not be called with illegal arguments");
	}
}

// Emit Functions----------------------------------
void Compiler::emit(string label, string instruction, string operands, string comment)
{
//Turn on left justification in objectFile 
//Output label in a field of width 8
	objectFile << left << setw(8) << label; 
//Output instruction in a field of width 8
	objectFile << left << setw(8) << instruction; 
//Output the operands in a field of width 24 
	objectFile << left << setw(24) << operands;
//Output the comment
	objectFile << left << comment << endl;
	
}

void Compiler::emitPrologue(string progName, string operand2)
{
//Output identifying comments at beginning of objectFile 
//Output the %INCLUDE directives
	time_t result = time(nullptr);
	 objectFile << "; Wonjae Hwang       " << ctime(&result);
	 objectFile << "%INCLUDE \"Along32.inc\"" << endl << "%INCLUDE \"Macros_Along.inc\"" << endl << endl;
	emit("SECTION", ".text"); 
	emit("global", "_start", "", "; program " + progName+ "\n");
	emit("_start:");


}

void Compiler::emitEpilogue(string operand1, string operand2)
{
//emit("","Exit", "{0}") 
//emitStorage();
	emit("","Exit", "{0}");
	objectFile << endl;
	emitStorage();

}

void Compiler::emitStorage()
{
	emit("SECTION", ".data"); 
//for those entries in the symbolTable that have  
// an allocation of YES and a storage mode of CONSTANT 
//{ call emit to output a line to objectFile } 
//emit("SECTION", ".bss") 
//for those entries in the symbolTable that have 
// an allocation of YES and a storage mode of VARIABLE 
//{ call emit to output a line to objectFile }

	for (auto it = symbolTable.cbegin(); it != symbolTable.cend(); ++it) 
	{
		if (((*it).second.getAlloc() == YES) && ((*it).second.getMode() == CONSTANT)) 
		{

			if((*it).second.getValue() == "false" )
			{
			emit((*it).second.getInternalName(), "dd", "0", ("; "+(*it).first));
			}
			else if ((*it).second.getValue() == "true")
			{
			emit((*it).second.getInternalName(), "dd", "-1", ("; "+(*it).first));
			}
			else 
			{
			emit((*it).second.getInternalName(), "dd", (*it).second.getValue(), ("; "+(*it).first));

			}
		}
	}

	objectFile << endl;
	
	emit("SECTION", ".bss", "", "");
	
	for (auto it = symbolTable.cbegin(); it != symbolTable.cend(); ++it)
	{
		if (((*it).second.getAlloc() == YES) && ((*it).second.getMode() == VARIABLE)) 
		{
			emit((*it).second.getInternalName(), "resd", "1", ("; "+(*it).first));
		}
	}
 
}


// Lexical routines---------------------------------------
string Compiler::nextToken() //returns the next token or end of file marker
{
	token = "";
	
	while (token == "")
	{
		if (ch == '{') 
		{ 
			while (ch != END_OF_FILE && ch != '}') 
			{
				nextChar();
			}
			if (ch == END_OF_FILE) 
			{
				processError("unexpected end of file");
			} 
			if(ch == '}')
			{				
				nextChar();
			}
		}
		else if (ch == '}') 
		{
			processError("'}' cannot begin token");
		}
		else if (isspace(ch)) 
		{
			nextChar();
		}
		else if (isSpecialSymbol(ch)) 
		{
			token = ch;
			nextChar();
		}
		else if (islower(ch)) 
		{
			token = ch;
			nextChar();
			char prev = ' ';
			while (((ch == '_') || (isalpha(ch)) || (isdigit(ch))) && (ch != END_OF_FILE)) 
			{
				prev = ch;
				token += ch;
				nextChar();
				if (prev == '_' && ch == '_') 
				{
					processError("error '_' must be followed by a letter or number");
				}
			}
			if (ch == END_OF_FILE) 
			{
				processError("unexpected end of file");
			}
			
		}
		else if (isdigit(ch)) 
		{
			token = ch;
			nextChar();
			while ((isdigit(ch)) && (ch != END_OF_FILE))
			{
				token += ch;
				nextChar();
			}
			//if (ch == END_OF_FILE)
			//{
			//	processError("unexpected end of file");
			//}
		}
		else if (ch == END_OF_FILE) 
		{
			token =  ch;
		}
		else 
		{
			processError("illegal symbol");
		}
	}
	
	return token;
	
}


char Compiler::nextChar() // returns the next character or END_OF_FILE marker
{
	//read in next character
	sourceFile.get(ch);
	
	static char prev = '\n';
 
    if(sourceFile.eof())
	{
        ch = END_OF_FILE;
	}
	
    if(ch != '$')
	{      
        if( prev == '\n')
        {
            lineNo++;
            listingFile <<  setw(5) << right<< lineNo << "|";
        }
		
        listingFile << ch;
    }
    else
	{
        listingFile << endl;
	}
	
    prev = ch;


    return ch;
	
	
}




